#### generate basis functions
tmp = diag(T_data)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
#### generate basis functions
tmp = diag(T)
tmp
W = matrix(NA,T,T)
W
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
c(a@V[[5]],unlist(a@W[5:1]))
str(c(a@V[[5]],unlist(a@W[5:1])))
str(W[t,])
# rm(list = setdiff(ls(), "data"))
rm(list = ls())
source('simulation_functions.R')
source('performance_functions.R')
source('call_changepoint.R')
source('MCMC_changepoint.R')
source('call_changepoint_newB.R')
source('MCMC_changepoint_newB.R')
source('MCMC_changepoint_newB_uniq_sigma.R')
setwd("C:/E/1_BFGM/Code)
source('simulation_functions.R')
source('performance_functions.R')
source('call_changepoint.R')
source('MCMC_changepoint.R')
source('call_changepoint_newB.R')
source('MCMC_changepoint_newB.R')
source('MCMC_changepoint_newB_uniq_sigma.R')
source('Helper_functions_mcmc.R')
source('call_known_FLC_v2_chop_basis.R')
source('Call_functions.R')
source('MCMC_algorithms.R')
source('try.R')
# Generate static data ---------------------------------------------------------------
# Simulation parameters:
p = 15  # Number of curves
K_true = 5 # Number of functional loading curves
n = 50   # Number of observations
T_data = 75; T = T_data
sigma_epsilon_true = 0.1
pii_local = 1
basis_type_true = 'polynomial'
# Simulate data:
set.seed(1)
data = simulate_static_data(p, K_true, n, T_data,
pii_local,
sigma_epsilon_true,
basis_type_true,
data = NULL,
disp = FALSE)
y <- array(NA,c(n,p,T))
for (i in 1:n){
for (j in 1:p){
y[i,j,] = data$Y[i,,j]
}
}
## load packages and R functions
setwd("C:/E/1_BFGM/Code/FunGraph-main")
library(wavelets)
library(doParallel)
library(foreach)
#registerDoParallel(24)
source('fgraph_cclasso.R')
source('Cmat_update.R')
source('Dmat_update.R')
source('Lam_update.R')
#### specify graphical model
p = 10
## specify precision matrix of error and auto-regressive matrix A
T = 128
tt = 1:T
r.max <- -0.99
r1 <- sapply(tt,function(t) min(max(0,t-T/4),T/2)*(r.max/(T/2)))
r2 <- r.max - r1
Sigma.err <- rep(list(diag(p)),T)
for(t in 1:T) {
Omega.tmp <- diag(c(rep(2,6),rep(3,4)))
Omega.tmp[which(G1==1)] <- r1[t]
Omega.tmp[which(G2==1)] <- Omega.tmp[which(G2==1)] + r2[t]
Sigma.tmp <- solve(Omega.tmp)
Sigma.err[[t]] <- diag(diag(Sigma.tmp)^-0.5) %*% Sigma.tmp %*% diag(diag(Sigma.tmp)^-0.5)*2
}
A <- diag(1,p)
## true conditional cross-covariance graph
Sigmas1.true <- G1.true <- G1.neg <- rep(list(diag(p)),T)
for(t in 1:T){
if(t == 1) {
Sigmas1.true[[t]] <- Sigma1 <- Sigma.err[[1]]
} else {
Sigmas1.true[[t]] <- Sigma1 <- A %*% Sigma1 %*% t(A) * 0.5 + Sigma.err[[t]] * 0.5
}
G1.true[[t]] <- (abs(solve(Sigma1)) > 0.1)*1
G1.neg[[t]] <- (abs(solve(Sigma1)) < 0.001)*1
}
G1.true <- abind(G1.true,along=3)
G1.neg <- abind(G1.neg,along=3)
####generate data
set.seed(9999)
n <- 50; p=10; T=128
y <- array(NA,c(n,p,T))
for(t in 1:T){
err <- matrix(rnorm(n*p),n) %*% chol(Sigma.err[[t]])
if(t == 1) y[,,t] <- err else
y[,,t] <- t(apply(y[,,t-1],1,function(x) A%*%x))*sqrt(0.5) + err*sqrt(0.5)
}
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
#### run Bayesian functional graph
MCMCspecs = list(B=1000,thin=5,burnin=1000,update=1000);
D_prior = list(a=0.1,b=0.1); lam_prior = list(a=0.1,b=1);
fgbay.samp <- fgraph_ccc(y,Phi,MCMCspecs,D_prior,lam_prior)
fgbay.est <- array(diag(p),c(p,p,T))
for(t in 1:T) fgbay.est[,,t][upper.tri(diag(p))] <- apply(fgbay.samp$ccc[,t,],1,function(x) (quantile(x,0.025)>0 | quantile(x,0.975)<0)*1)
#### calculate TPs and FPs
tmp <- matrix(FALSE,p,p); tmp[upper.tri(tmp)] <- TRUE
uptri.ind <- array(tmp,c(p,p,T))
## TPs
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
## FPs
sum((fgbay.est+G1.neg==2)[uptri.ind])/sum(G1.neg[uptri.ind])
# rm(list = setdiff(ls(), "data"))
rm(list = ls())
setwd("C:/E/1_BFGM/Code")
source('simulation_functions.R')
source('performance_functions.R')
source('call_changepoint.R')
source('MCMC_changepoint.R')
source('call_changepoint_newB.R')
source('MCMC_changepoint_newB.R')
source('MCMC_changepoint_newB_uniq_sigma.R')
source('Helper_functions_mcmc.R')
source('call_known_FLC_v2_chop_basis.R')
source('Call_functions.R')
source('MCMC_algorithms.R')
source('try.R')
# Generate static data ---------------------------------------------------------------
# Simulation parameters:
p = 15  # Number of curves
K_true = 5 # Number of functional loading curves
n = 50   # Number of observations
T_data = 75; T = T_data
sigma_epsilon_true = 0.1
pii_local = 1
basis_type_true = 'polynomial'
# Simulate data:
set.seed(1)
data = simulate_static_data(p, K_true, n, T_data,
pii_local,
sigma_epsilon_true,
basis_type_true,
data = NULL,
disp = FALSE)
y <- array(NA,c(n,p,T))
for (i in 1:n){
for (j in 1:p){
y[i,j,] = data$Y[i,,j]
}
}
## load packages and R functions
setwd("C:/E/1_BFGM/Code/FunGraph-main")
library(wavelets)
library(doParallel)
library(foreach)
#registerDoParallel(24)
source('fgraph_cclasso.R')
source('Cmat_update.R')
source('Dmat_update.R')
source('Lam_update.R')
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=7)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
a = dwt(tmp[t,],filter='haar',n.levels=7)
a = dwt(tmp[t,],filter='haar',n.levels=5)
a@V[[5]]
unlist(a@W[5:1])
str(c(a@V[[5]],unlist(a@W[5:1])))
#### specify graphical model
p = 10
G0 <- diag(0,p)
G0[1,2] <- G0[1,3] <- G0[2,3] <- G0[7,8] <- G0[7,9] <- G0[8,9] <- 1
G1 <- G2 <- G0
G1[4,5] <- G1[5,6] <- G1[4,6] <- 1
G2[7,10] <- G2[8,10] <- G2[9,10] <- 1
G0 <- G0 + t(G0); G1 <- G1 + t(G1); G2 <- G2 + t(G2)
## specify precision matrix of error and auto-regressive matrix A
T = 128
tt = 1:T
r.max <- -0.99
r1 <- sapply(tt,function(t) min(max(0,t-T/4),T/2)*(r.max/(T/2)))
r2 <- r.max - r1
Sigma.err <- rep(list(diag(p)),T)
for(t in 1:T) {
Omega.tmp <- diag(c(rep(2,6),rep(3,4)))
Omega.tmp[which(G1==1)] <- r1[t]
Omega.tmp[which(G2==1)] <- Omega.tmp[which(G2==1)] + r2[t]
Sigma.tmp <- solve(Omega.tmp)
Sigma.err[[t]] <- diag(diag(Sigma.tmp)^-0.5) %*% Sigma.tmp %*% diag(diag(Sigma.tmp)^-0.5)*2
}
A <- diag(1,p)
## true conditional cross-covariance graph
Sigmas1.true <- G1.true <- G1.neg <- rep(list(diag(p)),T)
for(t in 1:T){
if(t == 1) {
Sigmas1.true[[t]] <- Sigma1 <- Sigma.err[[1]]
} else {
Sigmas1.true[[t]] <- Sigma1 <- A %*% Sigma1 %*% t(A) * 0.5 + Sigma.err[[t]] * 0.5
}
G1.true[[t]] <- (abs(solve(Sigma1)) > 0.1)*1
G1.neg[[t]] <- (abs(solve(Sigma1)) < 0.001)*1
}
G1.true <- abind(G1.true,along=3)
G1.neg <- abind(G1.neg,along=3)
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
T = 75
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
T = 200
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
T = 128
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
View(dwt)
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
str(w)
str(W)
plot(W[1,])
plot(W[,1])
help(dwt)
a = dwt(tmp[t,],filter='haar')
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
T = 200
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar')
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
## specify precision matrix of error and auto-regressive matrix A
T = 128
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
str(c(a@V[[5]],unlist(a@W[5:1])))
str(a@V[[5]])
str(unlist(a@W[5:1]))
T
a@level
dwt
str(unlist(a@W[5:1]))
str(a)
T = 200
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
str(a)
sqrt(128)
2^5
2^6
2^7
2^8
T
T = 128
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
plot(Phi[,1])
plot(Phi[,1])
plot(Phi[1,])
plot(Phi[10,])
plot(Phi[40,])
plot(Phi[100,])
plot(Phi[6,])
# rm(list = setdiff(ls(), "data"))
rm(list = ls())
setwd("C:/E/1_BFGM/Code")
source('simulation_functions.R')
source('performance_functions.R')
source('call_changepoint.R')
source('MCMC_changepoint.R')
source('call_changepoint_newB.R')
source('MCMC_changepoint_newB.R')
source('MCMC_changepoint_newB_uniq_sigma.R')
source('Helper_functions_mcmc.R')
source('call_known_FLC_v2_chop_basis.R')
source('Call_functions.R')
source('MCMC_algorithms.R')
source('try.R')
2^6
2^7
2^8
# Generate static data ---------------------------------------------------------------
# Simulation parameters:
p = 15  # Number of curves
K_true = 5 # Number of functional loading curves
n = 50   # Number of observations
T_data = 128; T = T_data
sigma_epsilon_true = 0.1
pii_local = 1
basis_type_true = 'polynomial'
# Simulate data:
set.seed(1)
data = simulate_static_data(p, K_true, n, T_data,
pii_local,
sigma_epsilon_true,
basis_type_true,
data = NULL,
disp = FALSE)
y <- array(NA,c(n,p,T))
for (i in 1:n){
for (j in 1:p){
y[i,j,] = data$Y[i,,j]
}
}
## load packages and R functions
setwd("C:/E/1_BFGM/Code/FunGraph-main")
library(wavelets)
library(doParallel)
library(foreach)
#registerDoParallel(24)
source('fgraph_cclasso.R')
source('Cmat_update.R')
source('Dmat_update.R')
source('Lam_update.R')
#### generate basis functions
tmp = diag(T)
W = matrix(NA,T,T)
for(t in 1:T) {
a = dwt(tmp[t,],filter='haar',n.levels=5)
W[t,] = c(a@V[[5]],unlist(a@W[5:1]))
}
Phi <- solve(W)
MCMCspecs = list(B=1000,thin=5,burnin=1000,update=1000);
D_prior = list(a=0.1,b=0.1); lam_prior = list(a=0.1,b=1);
fgbay.samp <- fgraph_ccc(y,Phi,MCMCspecs,D_prior,lam_prior)
fgbay.est <- array(diag(p),c(p,p,T))
for(t in 1:T) fgbay.est[,,t][upper.tri(diag(p))] <- apply(fgbay.samp$ccc[,t,],1,function(x) (quantile(x,0.025)>0 | quantile(x,0.975)<0)*1)
tmp <- matrix(FALSE,p,p); tmp[upper.tri(tmp)] <- TRUE
uptri.ind <- array(tmp,c(p,p,T))
fgbay.est[,,t]
str(fgbay.est)
## TPs
G1.true = data$G_x_true
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
str(data$G_x_true)
str(uptri.ind)
#### specify graphical model
p = 10
G0 <- diag(0,p)
G0[1,2] <- G0[1,3] <- G0[2,3] <- G0[7,8] <- G0[7,9] <- G0[8,9] <- 1
G1 <- G2 <- G0
G1[4,5] <- G1[5,6] <- G1[4,6] <- 1
G2[7,10] <- G2[8,10] <- G2[9,10] <- 1
G0 <- G0 + t(G0); G1 <- G1 + t(G1); G2 <- G2 + t(G2)
## specify precision matrix of error and auto-regressive matrix A
T = 128
tt = 1:T
r.max <- -0.99
r1 <- sapply(tt,function(t) min(max(0,t-T/4),T/2)*(r.max/(T/2)))
r2 <- r.max - r1
Sigma.err <- rep(list(diag(p)),T)
for(t in 1:T) {
Omega.tmp <- diag(c(rep(2,6),rep(3,4)))
Omega.tmp[which(G1==1)] <- r1[t]
Omega.tmp[which(G2==1)] <- Omega.tmp[which(G2==1)] + r2[t]
Sigma.tmp <- solve(Omega.tmp)
Sigma.err[[t]] <- diag(diag(Sigma.tmp)^-0.5) %*% Sigma.tmp %*% diag(diag(Sigma.tmp)^-0.5)*2
}
A <- diag(1,p)
## true conditional cross-covariance graph
Sigmas1.true <- G1.true <- G1.neg <- rep(list(diag(p)),T)
for(t in 1:T){
if(t == 1) {
Sigmas1.true[[t]] <- Sigma1 <- Sigma.err[[1]]
} else {
Sigmas1.true[[t]] <- Sigma1 <- A %*% Sigma1 %*% t(A) * 0.5 + Sigma.err[[t]] * 0.5
}
G1.true[[t]] <- (abs(solve(Sigma1)) > 0.1)*1
G1.neg[[t]] <- (abs(solve(Sigma1)) < 0.001)*1
}
G1.true <- abind(G1.true,along=3)
G1.neg <- abind(G1.neg,along=3)
str(G1.true)
T
## TPs
G1.true = array(NA, dim = c(p,p,T_data))
for (t in 1:T_data){
G1.true = data$G_x_true + 0
}
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
T
fgbay.est <- array(diag(p),c(p,p,T))
for(t in 1:T) fgbay.est[,,t][upper.tri(diag(p))] <- apply(fgbay.samp$ccc[,t,],1,function(x) (quantile(x,0.025)>0 | quantile(x,0.975)<0)*1)
p
p=15
T
str(data$G_x_true)
str(data$Y)
p=15
fgbay.est <- array(diag(p),c(p,p,T))
for(t in 1:T) fgbay.est[,,t][upper.tri(diag(p))] <- apply(fgbay.samp$ccc[,t,],1,function(x) (quantile(x,0.025)>0 | quantile(x,0.975)<0)*1)
tmp <- matrix(FALSE,p,p); tmp[upper.tri(tmp)] <- TRUE
uptri.ind <- array(tmp,c(p,p,T)
)
## TPs
G1.true = array(NA, dim = c(p,p,T_data))
for (t in 1:T_data){
G1.true = data$G_x_true + 0
}
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
str(fgbay.est)
str(G1.true)
T_data
## TPs
G1.true = array(NA, dim = c(p,p,T_data))
for (t in 1:T_data){
G1.true[,,t] = data$G_x_true + 0
}
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
## FPs
sum((fgbay.est+G1.neg==2)[uptri.ind])/sum(G1.neg[uptri.ind])
View(get_mcmc_perf_blocked_graph_v2)
G1.neg = G1.true
## TPs
G1.true = array(NA, dim = c(p,p,T_data))
G1.neg = G1.true
for (t in 1:T_data){
G1.true[,,t] = data$G_x_true + 0
G1.neg[,,t] = !data$G_x_true + 0
}
sum((fgbay.est+G1.true==2)[uptri.ind])/sum(G1.true[uptri.ind])
## FPs
sum((fgbay.est+G1.neg==2)[uptri.ind])/sum(G1.neg[uptri.ind])
